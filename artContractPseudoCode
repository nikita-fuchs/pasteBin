=== Pseudo code art auction ===

// Notice: Normally, a winner needs to claim his win in a smart contract based auctions, because claiming the good one
// bidder won cannot be triggered automatically just because currentBlock equals or is greater than auctionEndBlock ;)
// So a transaction is needed. In this case, I suggest doing the following:
// If currentBlock >= auctionEndBlock, let's display this auction as finished, in UI.
// No one will be able to bid on it anyway.

// I propose for the smart contract to not keep track of which painting was already dealt with, else the whole project 
// gets more complicated and buggy, this should be handled elsewhere.

// For none of the functions I checked if the required parameters were actually set by the user's transaction,
// is this checked automatically on some level actually? 

//Changes in this branch (selected): 
// 1. If a transaction is still active or not is only determined by checking if current block > the transaction's endblock
// 2. No automatic forwarding of AE for now: Admins must withdraw AE manually and leave anough in contract to reimburse outbidded users
// 3. The highest bidder will be the one paying the most per minute (!) of time. To level out downsides of this, I recommend 
//      that the admins shall create auctions for picutres with higher and lower minute requirements, the new parameters I included in the 
//      startAuction function allow playing around here.

// Todo: Canceling of transactions (with reimbursement of the bidders, of course!)
// So here we go:

// define admins, maybe with a mapping?
address => bool : map isAdmin

// have a unique ID for every auction, start with zero and count up by one. this will also serve as an index later
// for listing / handling all auctions.
uniqueAuctionId: int;

// save all past and ongoing auctions in a map (or the sofia equivalent of an array). Because the uniqueAuctionId is a counter
// it will be easy to iterate over this data later to retrieve every entry as we know all the key values for this map.
// "auction" type is defined a little further below.
int => auction : map allAuctions;


// define a bid;
bid = {
    bidder: address // bidder, obviously
    offeredPerMinute: int // amount that was offered/paid per minute
    minuteAmount: int // the amount of minutes a bidder bidded for 
    totalAmount: int // this is actually optional, as you could calculate it from the above two.
    pictureID: *something* // (you're going to put the unique artwork identifier here later, so pick some suitable data type)
}

// define an auction: 
auction = {
    id: int,  //the unique auction ID
    minuteCapacity: int // the amount of drone time minutes that is on sale in this auction
    maximumMinutesPerBid: int // allow limiting the amount of minutes that a user can bid on in this auction. This way, you can allow only smaller pictures in one auction. This prevents big pictures with lots of minutes resulting with a high "minutes * price per minute" to automatically be the winners.
    minimumMinutesPerBid: int // lower limit to prevent spam
    //slot: int, // for easier handling/displaying in UI later, when reading contract data
    highestBidsSet: bid[] // array of previously defined bid type - whenever a bid is higher than the latest entry of this array, it gets added to this array. Thereby, we know that the winners will be a couple of the last entries of this array. which ones will be defined by the next value:
    //active: bool // is the auction still active or not? :)
    startBlock // when does it start ?  
    endBlock: int // the blocknumber of the block when the auction is supposed to end

    // I know "active" could possibly be derived from checking if (currentblock>=endBlock), but let's save on code execution here?
}

// optional: Have a map that draws a relation between auctions and the unique identifier of the winning bidder's picture
// this information could be gathered elsehow, too, but transactions are cheap still so we make our life easier
// again, you can use an array-equivalent here, too. The key values will always be 0,1,2,3,4...

int => *something* : map winningPictureIdByAuctionID

// have a function to start a new auction. 

// CAUTION: make this function be triggerable ONLY by an admin. 

startAuction (_minuteCapacity: int, _maximumMinutesPerBid: int, _startBlock: int, _blockDuration: int, *someOtherParamsEventually*)  ) stateful : int =

    // make sure this can only be called from within this contract or by admins
    require(isAdmin[Call.caller])
    
    // make sure the end of the auction lies in the future
    require (_startBlock + _blockDuration > block.number)

    // Optional: make sure the auction starts in the future - this can be annoying for testing
    require (_startBlock > block.number)

        //3.1 create the auction itself...
        let auction newAuction = {
            id: uniqueAuctionId 
            minuteCapacity: _minuteCapacity
            maximumMinutesPerBid: _maximumMinutesPerBid
            minimumMinutesPerBid: _minimumMinutesPerBid
            highestBidsSet: null // or, if sophia doesn't like null, initiate a bid[] type value here with bogus zero-like values for the fields.
            startBlock: _startBlock
            endBlock: _startBlock + _blockDuration

        // 3.2 ... put it in the allAuctions mapping...
        allAuctions[uniqueAuctionId] = newAuction // of course you can combine step 3.1 and 3.2

        // 3.4 ...and don't forget to count up the uniqueAuctionId for the next use ;)
        uniqueAuctionId++;
        
        // and return the uniqueAuctionId of the new auction, important for placeBid() !
        return uniqueAuctionId
        }
    } 
}

// the function for bidding - the bis with the highest amount paid per minute (!) is considered as winner in this case. Call.value is an invisible parameter here, so to say.
// @param _id: the referenced auction
// @param _minutes: the minutes you are planning to buy with this bid
// @param _picture: the ID of the picture this bid is for
function placeBid (_id : int, _minutes : int, _picture: *uniquePictureIDdataType*) stateful payable {
    
    // check for payment
    require (Call.value > 0)

    // check if the amount of minutes bid for is not too big - you could also set a maximum here, to some percentage of the total amount of biddable minutes, so more people have a chance and one does not snatch all the minutes
    require(_minutes <= allAuctions[_id].minuteCapacity)

    // check if the auction is (still) running 
    require( block.number > allAuctions[_id].startBlock && block.number < allAuctions[_id].endBlock)

    // check if bid fits auction's "minutes criteria"
    require (allAuctions[_id].minimumMinutesPerBid <= _minutes && allAuctions[_id].maximumMinutesPerBid >= _minutes)

    // prepare a helper, fill it with the data of this bid for now.
    bid thisBid = {
        bidder: Call.caller
        offeredPerMinute: Call.value / _minutes // watch out for possible strange arithmetic behaviour of sophia here 
        minuteAmount: _minutes
        totalAmount: Call.value
        pictureID: _picture 
    } 
    // if there is no bid yet for this auction, just add this one to highestBidsSet[]
    if (allAuctions[_id].highestBidsSet.length == 0){
        allAuctions[_id].highestBidsSet[0] == thisBid; // I guess in sofia you would just prepend thisBid to what would be an empty list highestBidsSet
                                                        // We will pre(!) pend  
    } else {

    // if there ARE bids already, check if this bid is the "highest" 
    // by dividing the transaction value with the amount of minutes this bid was made for and checking, 
    // if the "offered per minute" value is the highest of all among the before.
    // optional: you can require the bid to be at least X amount higher than the last highest one 

    delete:// define a helper
    delete: // var int highestBid = allAuctions[_id].highestBidsSet.length - 1 // this is the index of the highest bid in highestBidsSet[] of this auction
        if (thisBid.offeredPerMinute > allAuctions[_id].highestBidsSet[0].offeredPerMinute ) {
            
            // here we will store the new set of highest bids that fit in the minuteCapacity of the auction.
            var bid[] newHighestBidsSet;

            // as we already know who is the new highest bidder, we will put him first in that new set of highest bidders:
            newHighestBidsSet.push(thisBid);

            // now, add all the minute amounts of the previous highest bids to the new highest bid, to see how many old ones still fit in the acution's minuteCapacity.
            // As long as a the sum doesn't exceed the auction's minute capacity, let the old bid be part of the newHighestBidsSet. 
            // That bid that exceeds the minuteCapacity gets dropped out and the bidders get their bids returned.
            // We start iterating the array from the start.
            // Following boolean shall indicate to the for loop, from when on every bid in the highestBidsSet is to return to the sender. This
            // is to prevent big bids to be kicked out and having small-minute bids slip in to their place in the for loop below.
            // as soon as the following bool will turn true, every old bid will be refunded, even if it would have fit in the available time slot.
            var bool returnFromHereOn = false;

            // (but first, we define a helper - it is to keep track of the sum of minutes during the addition that is not supposed to exceed the auction's minuteCapacity, we initialize this value with the current highest bid's minutes amount, because this bid HAS to be included)
            // (maybe there is also a more elegant way)
            // so we take the amount of minutes the new highest bidder wants...
            var int currentMinuteSum = thisBid.minuteAmount;
            
            //...and check, if there is still enough room for the previously highest bids.
            for (i = 0; i <= allAuctions[_id].highestBidsSet.length; i++){

                // check if we are only returning bids already. If not... 
                if (!returnFromHereOn){

                // if there is room to fit in the minutes of the previous high bids, ....
                if (currentMinuteSum + allAuctions[_id].highestBidsSet[i] < allAuctions[_id].minuteCapacity){
                    //... then keep the old bids.
                    newHighestBidsSet.push[allAuctions[_id].highestBidsSet[i]]; // example: 100 minutes are available, the previous n bids took up only 15 and 35, the new highest bid takes 30, so they all fit in the 100. The new highestBids now take 30, 15 and 35 minutes.
                } else {
                    // But if one of the old bids starts exceeding the available time capacity:
                    
                    // tell the script that every bid from hereon will only be returned, it won't be part of the newHighestBidsSet
                    returnFromHereOn = true;

                    // now, this bid that needs to be returned is to be processed by the corresponding logic.
                    // try manipulating i so the for loop handles this one bid from the highestBidsSet[] twice. 
                    // This is okay to do so, becuase you won't land here a second time, but jump into the else case of 
                    // " if (!returnFromHereOn){ ...  " right away, as returnFromHereOn is true now.

                    i--

                    // if this is not possible, just implement the code logic from the following else part...
                }
            } else {

                //return the bid of the bidders which are not part of the highestBidsSet[] anymore
                transfer(allAuctions[_id].highestBidsSet[i].totalAmount).to(allAuctions[_id].highestBidsSet[i].bidder);

            }
                
            }

                //since the newHighestBidsSet[] now consists only of the new highest bid and the previous highest bidders, 
                // we need to ovberwrite the old highestBidsSet with it.
                allAuctions[_id].highestBidsSet = newHighestBidsSet;

        }
    }
}

// helper function for retrieving all finished auctions' picture IDs for one slot. Note that this is run locally so we 
// don't care about escessive looping / if condition checking.
// of course, this could also be performed through calls to allAuctions from without the contract ( see getAuctionById() ), but i'd prefer this.

// Caution: If there are limitations on return data size, perform the getting of finished auctions off-contract with the getter function getAuctionByIdI() !
getFinishedAuctionsPictureIDsByAuctionID(_id : int) : *data type of unique picture identifier* {
    
    // define the return data 
    let allWinningPictures[];
    
    // iterate through all highestBidsSet bids...
    for (i=0; i<allAuctions[_id].highestBidsSet.length, i++){

            // ...get the winning bid's picture ID and push it to the return data
            allWinningPictures.push(allAuctions[i].highestBidsSet[i].pictureID)
        
    }

    // return the IDs of all pictures that won an auction, beginning with the highest bidder, then second highest, and so forth.
    return allWinningPictures;
}


// get one auction byID, also run locally
//hopefully it's possible to return an own-defined, struct-like datatype as a whole, if not you'll have to help yourselves.. ;)
function getAuctionById(int : _auction) : auction {
    return allAuctions[_auction];
}

// if you have read until here, notice the following: If an auction is started and nobody bids for 
// it until the endblock, the ending of that auction will make it simply have no winner, and that's okay. 
// the new creation of a bid creates an auction that will, from that moment, run for the predefined amount of blocks.

function withdraw (_amount: int) {

    // make sure it's an admin
    require(Call.caller == this || isAdmin[Call.caller])

    // you are of course free to define the target of withdrawing
    send(_amount).to(call.caller)
}
